name: Validate Driver Documentation

on:
  pull_request:
    branches:
      - main
    paths:
      - 'src/content/docs/**'
      - 'public/images/**'

jobs:
  validate-files:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Validate Driver Structure
        run: |
          # Check for driver.md, driver.yaml, driver.webp, and optional images/ directory
          find src/content/docs -mindepth 3 -maxdepth 3 -type d | while read -r driver_dir; do
            driver_name=$(basename "$driver_dir")
            
            # Check for driver.md
            if [ ! -f "$driver_dir/$driver_name.md" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.md'."
              exit 1
            fi

            # Check for driver.yaml
            if [ ! -f "$driver_dir/$driver_name.yaml" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.yaml'."
              exit 1
            fi

            # Check for driver.webp
            if [ ! -f "$driver_dir/$driver_name.webp" ]; then
              echo "::error file=$driver_dir::Driver directory '$driver_dir' must contain '$driver_name.webp'."
              exit 1
            fi
          done

          # Use regex to ensure all .md, .yaml, and .webp files are at the correct driver level and named correctly
          # Expected path format: src/content/docs/{category}/{manufacturer}/{driver}/{driver_name}.(md|yaml|webp)
          find src/content/docs -type f -regex ".*\\.\\(md\\|yaml\\|webp\\)$" -print0 | while IFS= read -r -d $'\0' file; do
            # Extract driver_name from the file path for comparison
            # Example: file = src/content/docs/category/manufacturer/driver_name/driver_name.md
            # Expected pattern for driver_name: ([^/]+)
            driver_dir_name=$(basename "$(dirname "$file")")
            file_base_name=$(basename "$file")
            file_extension="${file_base_name##*.}"
            file_name_without_ext="${file_base_name%.*}"
            file_dir=$(dirname "$file")

            is_primary_file_name_match=false
            if [[ "$file_name_without_ext" == "$driver_dir_name" ]]; then
              if [[ "$file_extension" == "md" || "$file_extension" == "yaml" || "$file_extension" == "webp" ]]; then
                is_primary_file_name_match=true
              fi
            fi

            is_primary_file_dir_match=false
            if echo "$file_dir" | grep -Pq "^src/content/docs/[^/]+/[^/]+(?:/[^/]+)?$"; then
              is_primary_file_dir_match=true
            fi

            is_image_subdir_match=false
            if echo "$file" | grep -Pq "^src/content/docs/[^/]+/[^/]+/[^/]+/images/[^/]+\\.webp$"; then
              is_image_subdir_match=true
            fi

            if $is_primary_file_name_match && $is_primary_file_dir_match; then
              # This file is a primary driver file and correctly named/located.
              :
            elif $is_image_subdir_match; then
              # This file is an image within the driver's images/ subdirectory and correctly named.
              :
            else
              echo "::error file=$file::Misplaced or incorrectly named file. Expected primary driver file format: src/content/docs/{{category}}/{{manufacturer}}/{{driver_name}}/{{driver_name}}.(md|yaml|webp) or image file format: src/content/docs/{{category}}/{{manufacturer}}/{{driver_name}}/images/{{image_name}}.webp"
              exit 1
            fi
          done

      - name: Validate All Image Formats
        run: |
          # Check all images in src/content/docs (including driver.webp and images/ subdirectory)
          # Ensure no other image formats are present anywhere in src/content/docs
          find src/content/docs -type f -regex ".*\\.\\(png\\|jpg\\|jpeg\\|gif\\|bmp\\)$" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Image file '$file' must be in .webp format. Other formats are not allowed in driver documentation directories."
            exit 1
          done

          # Check all images in public/images/manufacturers
          find public/images/manufacturers -type f ! -name "*.webp" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Manufacturer logo '$file' must be in .webp format."
            exit 1
          done

          # Check all images in public/images/categories
          find public/images/categories -type f ! -name "*.webp" -print0 | while IFS= read -r -d $'\0' file; do
            echo "::error file=$file::Category icon '$file' must be in .webp format."
            exit 1
          done

      - name: Validate Referenced Images Exist
        run: |
          # Validate category logos based on directory names
          find src/content/docs -mindepth 1 -maxdepth 1 -type d | while read -r category_dir; do
            category_name=$(basename "$category_dir")
            category_image="public/images/categories/${category_name}.webp"
            if [ ! -f "$category_image" ]; then
              echo "::error file=$category_dir::Category logo for directory '$category_name' not found at '$category_image'."
              exit 1
            fi
          done

          # Validate manufacturer logos based on directory names
          find src/content/docs -mindepth 2 -maxdepth 2 -type d | while read -r manufacturer_dir; do
            manufacturer_name=$(basename "$manufacturer_dir")
            manufacturer_image="public/images/manufacturers/${manufacturer_name}.webp"
            if [ ! -f "$manufacturer_image" ]; then
              echo "::error file=$manufacturer_dir::Manufacturer logo for directory '$manufacturer_name' not found at '$manufacturer_image'."
              exit 1
            fi
          done
